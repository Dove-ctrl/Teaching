#ifndef PID_H_
#define PID_H_

#include <math.h>

/* 
    1.  我要对电机做什么？

    简单的说，你需要让电机转起来，但事实上仅仅让电机转起来是远远不够的，
    因为你需要让电机转到合适的位置停下来，来完成你机器人的某个动作，
    因此，这里引入控制这个概念，你需要的是去控制电机。

    控制是一个很常见的事情，生活中随处可见：
    你烧水时水开了水壶会自动断电，
    你做饭时火大了你会手动调小火力，
    你开车时看到前方有弯道会打方向，
    你打cs时会控制弹道，也就是压枪，

    这都是控制的体现，而在上述控制中，如果你去进行一个评价，
    你会发现有些控制效果事实上完全取决人的经验，越是没经验的人控制的效果越差，
    例如：
    一个从不做饭的人，不太可能一次性就能调准火力的大小，
    而经验老道的厨师，也几乎不太可能把握不准需要的火候，
    一个刚拿驾照的司机，不太可能开AE86赢过GTR
    而常年开车的老司机拓海就能做到，
    一个从不玩射击游戏的人，让他玩AK，他的准星可能会飞到天上去，
    而让某职业选手上场，AK在他手里看起来就跟没有后坐力一样。

    因此，为了方便以上过程，自动控制就应运而生了。

    2. 为什么要PID控制，不用不行吗？

    分析上面的几个例子，它们的控制逻辑大概是这样的：
    水壶的温度传感器侦测到温度为100℃，就立刻断电，否则继续加热。
    你听见油滴噼啪作响，看见食材些许焦糊，你知道火大了，于是你调小火力，食材许久未见变色，你知道火小了，于是开大火力。
    司机看见前方有弯道，车道偏离越多他打的方向越多，车辆最后顺利转弯。
    cs职业选手开枪时，他发现弹道在往上偏，于是他立刻下划鼠标，保持弹道稳定。

    细心的人应该发现了，有些控制只单纯的根据给定的值去控制，至于控制效果怎样并不关心，
    而有些控制会根据控制效果去做相应调整，使得系统的某个状态保持稳定。

    这便是开环控制和闭环控制。
    开环控制系统中，控制结果不会影响控制量的大小。
    闭环控制系统中，控制结果会反过来影响控制量的大小。
    烧水壶只需要把水烧开就行了，至于水到底是多少度，烧水壶并不关心，这是开环控制，
    火力大小会影响做饭时的声光热等现象，你又会根据这些现象调控火力，
    车道偏离程度会影响司机打方向的多少，而司机打方向的多少也会影响车辆和车道的偏离程度，
    准星往上跳会影响职业选手下划鼠标的程度，而下划程度也会影响准星的位置，这便是闭环控制。

    闭环控制往往需要传感器参与计算，因为系统需要知道控制效果究竟如何，才能去调节控制量的大小，
    而开环控制的传感器并不参与控制量大小的调节，只是控制过程的开关而已。

    有些控制只需要开环就可以了，只需要让系统达到某个状态，例如烧开水，
    但是需要让系统到达某个值时，例如上述那三个例子，开环控制就会显得力不从心，控制效果会差很多，
    试想你做饭时如果只是单纯调大调小火力，而不根据声光热等现象进行判断，你或许永远没法做出佳肴，
    如果司机都是看到弯道就打方向，不管打方向有多少，汽车可能从一开始就会被认为是凶器，
    如果职业选手压枪都是无脑下划，那他应该不是个职业选手。

    电机控制也是同样的道理，你需要电机转到指定角度后，稳稳停下，需要一个闭环控制，这便是PID。

    可能你会问：电机旋转到指定角度，我直接让他停下不就行了吗，这跟烧开水没区别嘛。
    这其实跟烧开水区别很大，烧开水只需要水开了就行了，水温具体值并不是考虑要素，
    而电机旋转到指定角度这跟过程，角度是很重要的考虑要素。
    事实上，电机因为会接入负载，当旋转到指定角度时，你发出停止的命令已经来不及了，因为电机停下是需要时间的。
    而PID做的其实就是控制这个减速的过程，让电机能正好停在指定的角度。

    具体PID是如何运作的，PID文件夹里的pdf文件已经说的很详细了，这里就不展开
    下面只是给出程序的实现方法：
    
 */

class PID{
private:
    float error_curt , error_past , error_I , error_D;
    float P,I,D;
    bool first_time;
    bool arrived;
    float kp,ki,kd;
    float target , error_tol;
    float error_range_low , error_range_high;
    float output;
public:
    enum reset_type{
        _first_time , _I , _arrived , _all
    };
    PID();
    void reset(reset_type);
    void set_coefficient(float _kp,float _ki,float _kd);
    void set_target(float _target);
    void set_error_range(float _error_range_low,float _error_range_high);
    void set_error_tol(float _error_tol);
    float get_output();
    bool target_arrived();
    void update(float input);
};

#endif